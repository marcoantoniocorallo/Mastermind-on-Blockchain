In Solidity, for dynamic types like string, bytes, array, and struct, 
you must specify where the data is stored. 
For function parameters in external functions, 
the data location must be either memory or calldata.
`calldata` is used for external function parameters because it is more efficient, 
especially for read-only operations.
`memory` could also be used if the data needs to be copied

The emit statement, which triggers an event, modifies the blockchain's state. 
Even though triggering an event does not modify the contract's storage, 
it is considered a state-modifying action since it writes to the transaction logs.
In Solidity, functions that modify the state cannot be marked as view or pure. 
The view keyword is used for functions that only read from the state but don’t modify it,
while pure is used for functions that don’t even read from the state.

Prevented Security issues:
- DDOS creating new game:
  Eve wants to DDOS the game vectors creating a sequence of new games.
  1. The gas makes his work in preventing it.
  2. Furthermore, once a player creates a game, he cannot create any others.
- Make an user not available to play:
  If P1 creates a game for playing with P2, P2 is not forced to play with P1 and may want to play 
  with someone else or to play a quick game (random chosen).
- Per il problema della randomness è stato utililzzato l'hashblock del blocco precedente,
  come visto a lezione. Non è la soluzione migliore ma la migliore gratis
- Access control: il contratto Game memorizza l'indirizzo del contratto MasterMind e permette
  operazioni sensibili (settaggi) solo provenienti da quell'indirizzo (?)
  Game effettua anche i controlli sull'indirizzo di chi inizia la transazione, per verificare
  che sia codemaker o codebreaker, a seconda del turno
- Reentrancy: Lo stake viene settato a 0 prima di essere restituito dal metodo, inoltre viene 
  usata la funzione call settando il gas a 3500: abbastanza per inviare i soldi ma non abbastanza
  per inviarli due volte
- Bruteforce sul codice: salt 
- Integer overflow sull'id delle partite: utilizzato un uint256 => 2^256 numero improponibile di partite
  Si potrebbe aggiungere un controllo t.c. ogni ~mln di partite resetta l'id, ragionevole come quantità
  ma spreca gas inutilmente dato che 2^256 chissà se e quando verrà raggiunto

Design choices:
- Stake deciso off-chain, poi trasmesso come messaggio al contratto da entrambi i giocatori.
  Se i due stakes non coincidono, è probabile che uno dei due voglia barare, ma noon sappiamo chi.
  Per evitare queste situazioni, la partita viene chiusa (poco male dato che non era ancora iniziata)...
  Se i due stakes coincidono, vengono inviati. Se i soldi inviati da uno dei due non coincidono con
  quanto dichiarato, il player viene punito
- Punishment: lo stake viene dato all'altro giocatore (o me lo tengo io? :D) 
- id del game salvato off-chain sul client, inviato dal client per ogni operazione. 
  Il contratto fa dei controlli quando riceve una transazione con un dato id.
  Alternative erano mappare address => game, in modo da accedere alla partita di un giocatore
  direttamente tramite l'address, senza controllare l'ID. Ma questa soluzione avrebbe portato 
  a gestire una complessità maggiore in altri casi: uno su tutti, joinGame(ID) richiede di 
  accedere ad un game tramite il suo ID, dunque (data la struttura mapping di solidity) 
  si sarebbe comunque dovuto tenere un mapping id => game.
  Un'altra soluzione sarebbe appunto tenere entrambi i mapping, ma a quel punto un gioco è 
  accessibile tramite ID e il punto di debolezza continua ad esistere.
  Infine, un'ultima soluzione sarebbe quella di usare una struct che wrappa il vettore di games
  e che permette l'accesso al mapping address => game in modo publico e al mapping id => game 
  solo tramite apposite funzioni (ad es. quando si vuole fare una joinGame).
  Tuttavia questa soluzione aggiunge costi e complessità e si è preferito mantenere una struttura
  più semplice.
- OOP, security by design and by contract, decoupling...